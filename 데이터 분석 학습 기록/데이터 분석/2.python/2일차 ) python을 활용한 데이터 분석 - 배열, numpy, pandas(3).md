[[2.python]]
## **글 쓴 이유**

 - 금일은 2일차 python을 이용한 numpy관련 배열, 데이터 프레임 ,pandas에 대해 정리해보고자 함

 - python의 시리즈 , pandas 함수 , 데이터프레임 등 생소한 내용이 있어 같이 정리할 예정

## **Pandas(Panel Data + Python Data Analysis) ?** 

 - 파이썬 분석의 핵심 도구

 - 데이터를 분석하고 조작하는데 가장 널리 사용되는 오픈소스 라이브러리!

 - 특히 정형 데이터(표 형태의 데이터)를 다룰 때 Excel이나 DB처럼 사용가능!

### **Pandas의 구조**

#### **시리즈(Series)**

 - 원소를 세로 방향으로 나열한 것(1차원)

 - 인덱스와 값으로 구성됨  / 여기서 인덱스는 위치정보가 아닌 행이름으로 사용됨

 - 데이터 베이스의 한개의 열이나 엑셀의 한 개의 행과 비슷함

#### **데이터 프레임(DataFrame)**

 - 원소인 시리즈를 가로 방향으로 결합한것 (2차원)

 - 2차원 표 형태의 데이터 구조로 , Pandas의 핵심

 - 엑셀 시트나 SQL 테이블과 가장 흡사 , 대부분의 데이터 분석 작업이 DataFrame 중심으로 이루어짐

**- 데이터 프레임의 원소는 열(시리즈) , 열을 하나 선택하면 하나의 시리즈 , 시리즈 안의 한칸의 값은 셀값**

### **시리즈(Series)의 생성**

 - 시리즈로 만들 임의의 리스트 생성 

```
tp = [1,2.0,'3']
```

 **- 리스트(또는 1차원 배열)를 pandas 라이브러리 함수를 사용해서 시리즈로 변환함**

 **- data는 생성할 리스트이고 , index는 생성될 인덱스 값** 

 **** 이때 index는 위지 인덱스 데이터가 아닌 행이름 값이라고 생각하면 됨**

```
ss = pd.Series(data = tp , index = ['a','b','c'])
ss

# 출력
a      1
b    2.0
c      3
dtype: object
```

### **시리즈(Series)의 자료형 변환 및 계산**

 **- 기존 배열을 계산은 안되지만 시리즈로 생성하였을 경우에는 연산이 가능**

 **- 연산을 진행할 시리즈의 데이터 타입이 모두 정수 , 실수 , 문자열로 통일 되어 있지 않다면 오류가 발생**

 **-  시리즈의 데이터 타입을 통일시키기 위해 astype 메서드를 사용해서 계산을 할수있다**

```
# 원본 시리즈 테이블
a      1
b    2.0
c      3

# 정수(int) 형으로 변환 후 시리즈 내 데이터에 더할수있음
ss.astype(dtype = int) + 1

# 출력
a    2
b    3
c    4
dtype: int64

# 실수(float) 형으로 변환 후 시리즈 내 데이터에 더할수있음
ss.astype(dtype = float) + 1.1

# 출력
a    2.1
b    3.1
c    4.1
dtype: float64

# 문자열(str) 형으로 변환 후 시리즈 내 데이터에 더할수있음
ss.astype(dtype = str) + 'a'

# 출력
a      1a
b    2.0a
c      3a
dtype: object
```

### **시리즈(Series)의 인덱스에 대한 이해**

 **- 시리즈의 인덱스는 다음과 같은 특징을 가짐**

|   |
|---|
|시리즈를 생성할 때 인덱스를 지정하지 않으면 정수 0부터 시작|
|시리즈 인덱스를 정수 , 실수 또는 문자열로 변경 할 수 있음|
|시리즈 인덱스는 중복을 허용|
|시리즈에서 일부 원소를 선택하면 기존 인덱스르 유지|

 **- 시리즈 인덱스를 정수 인덱스(위치 데이터)가 아니라 행 이름으로 인식함**

|   |
|---|
|시리즈에서 위치 인덱스로 인덱싱 하고싶다면 iloc 인덱서를 추가하고 대괄호 안에 정수 인덱스를 넣어 가능 (리스트)|
|시리즈에서 행 이름으로 인덱싱 하고싶다면 loc 인덱서를 추가하고 대괄호 안에 행 이름을 넣어 인덱싱 가능 (딕셔너리 key값과 비슷)|

### **시리즈(Series)를 딕셔너리로 만들기**

 - 키와 값의 쌍을 원소로 갖는 딕셔너리를 생성

```
di1 = {'a':1 , 'b' : 2.0 , 'c' : '3'}

# 출력
{'a': 1, 'b': 2.0, 'c': '3'}
```

 - 딕셔너리로 시리즈를 만들때는 기존 시리즈를 만들 때와 동일하게 생성해주면 된다

 **- data는 딕셔너리 , index는 세팅하지않거나 딕셔너리의 key값과 동일하게 넣어줘야한다**

 **- 만약 index값이 딕셔너리의 key과 동일하지 않다면 결측값으로 채워줌**

```
# 원본
di1 = {'a':1 , 'b' : 2.0 , 'c' : '3'}

# 딕셔너리로 시리즈를 만들때는 딕셔너리의 key값이 index값으로 세팅되어 생성된다
sr = pd.Series(data = di1)

# 출력
a      1
b    2.0
c      3
dtype: object

# index값에 딕셔너리의 key값과 동일하게 넣어줘도 올바르게 생성 가능하다
pd.Series(data = di1 , index = ['a','b','c'])

# 출력
a      1
b    2.0
c      3
dtype: object

# 주의 딕셔너리로 시리즈를 만들때 임의의 index값을 세팅한다면 결측값(NULL)로 생성이 된다
pd.Series(data = di1 , index = [1,2,3])

# 출력
1    NaN
2    NaN
3    NaN
dtype: object
```

### **시리즈(Series)와 & , | , ^ 연산자**

 **- 일반 조건문과 반복문에서는 and , or 연산자가 사용됨**

```
ls = [1,2,3,4]
sr = pd.Series(ls)
for i in sr:
    print(i)
# 일반 프로그래밍에서는 조건문과 반복문을 자주 사용함
for i in sr:
    print(i >= 1 and i < 3)
    
# 출력
1
2
3
4
True
True
False
False
```

 **- 시리즈에 크기 비교 연산자를 사용했을 경우에는 시리즈 형태로 출력한다** 

```
# sr
[1,2,3,4]

# 결과는 시리즈 형태로 출력
sr < 3

# 출력
0     True
1     True
2    False
3    False
dtype: bool

# 결과는 시리즈 형태로 출력
sr >= 1

# 출력
a    True
b    True
c    True
d    True
dtype: bool
```

 **- 시리즈간 and , or 연산자는 사용 할 수 없다.**

 **- 그대신 비트 연산자 &(and)  , |(or) , ^(xor) , ~(not) 를 사용한다**

```
# sr 시리즈
[1,2,3,4]

# sr >= 1 and sr < 3 => 이거쓰면 에러발생
# and 대신 & 비트 연산자 사용
(sr >= 1) & (sr < 3)

# 출력
a     True
b     True
c    False
d    False
dtype: bool
```

 - 해당 비트 연산자를 사용해서 다양한 분석에 사용된다 (ex. ^(xor)연산을 사용해서 이전 / 현재 상태 변화 여부 판단)

 **- ~ (not) 연산자를 사용할때는 시리즈의 타입이 정수 타입인지 부울 타입인지 잘 판단하고 사용해야한다**

 **- 정수 타입이면 ~(not)이 논리 연산이 아닌 비트 연산이 들어가 보수 계산 처리가 되어 원하는 논리 값을 출력 할 수 없다**

 **- 부울 타입이면 ~(not)이 논리 연산으로 처리되어 반대의 값으로 출력된다**

 - 해당 예시는 다음 코드로 설명하겠다

```
# 시리즈간 xor 연산도 사용하는데 ^로 씀
# 이전 상태와 지금 상태의 변화 여부를 판단할때 주로 사용
st1 = pd.Series(data = [1,1,0,0])
st2 = pd.Series(data = [1,0,1,0])

# **case1)
# 이전과 현재의 상태가 1인 값 출력
print(st1 & st2)

# 출력
0    1
1    0
2    0
3    0
dtype: int64

# **case2)
# 이전과 현재의 상태 둘중 1이 있었다면 출력
print(st1 | st2)

# 출력
0    1
1    1
2    1
3    0
dtype: int64

# **case3)
# 이전과 현재의 상태가 1 -> 0 또는 0 -> 1 로 변경되었을경우 출력
print(st1 ^ st2)

# 출력
0    0
1    1
2    1
3    0
dtype: int64

# **case4)
# 이전과 현재의 상태가 1 -> 0 또는 0 -> 1 로 변경이 안되었을 경우 출력
# 하지만 시리즈의 데이터가 정수형이라 논리 연산이 아닌 비트연산으로 처리가 되어 보수계산으로 처리됨
print((~(st1 ^ st2)))

# 출력
0   -1
1   -2
2   -2
3   -1
dtype: int64

# **case5) 시리즈의 데이터를 부울 타입으로 세팅했을 경우
st1 = pd.Series(data = [True, True , False , False])
st2 = pd.Series(data = [True,False,True,False])

# 이전과 현재의 상태가 True -> False 또는 False -> True 로 변경이 안되었을 경우 출력
# 정수와 다르게 not 연산이 비트 연산이 아닌 논리 연산으로 처리됨
print((~(st1 ^ st2)))

# 출력
0     True
1    False
2    False
3     True
dtype: bool
```