[[2.python]]
## **글 쓴 이유**

 **-** 4일차도 통계 파일을 읽고 해당 데이터에 대한 전처리 방법들에 대해 설명하도록 한다

 - 금일은 날짜 시간값 처리와 apply 메서드에 대해 설명하도록 하겠다

## **날짜 시간형 변수 생성**

 - 통계 파일내 데이터들을 보다보면 년도 , 월 , 일 , 시간등 시간 데이터에 대한 항목을 볼수있다

 - 해당 데이터는 string 형태로 저장되어 있다

 - 시간 string은 datetime 형으로 변환하거나 사용 될 수 있다.

 - 해당 여기서 **datetime값은 유닉스 시간 기준으로 산정되어 날짜 값으로 계산되어 보여진다.**

#### **생성 관련 실습** 

1. 예시로 다음과 같이 임의의 날짜 데이터를 생성해보자

```
# 날짜 리스트 생성
days = ['2025-12-18' ,'1997-09-26']

# 해당 리스트를 활용해 날짜라는 열의 데이터 프레임을 생성
day_table = pd.DataFrame(days , columns = ['날짜'])

# 출력
	날짜
0	2025-12-18
1	1997-09-26

# 해당 데이터 프레임의 dtypes 정보
day_table.dtypes

# 출력
날짜    object
dtype: object
```

 2. 생성 후에 확인해보니 **날짜 열의 데이터 형식은 object 즉 string 형태로 저장되어 있음을 확인** 할 수 있다.

 3. 그렇다면 object를 어떻게 datetime 형식으로 바꿔야 하나 ?

 **4. pandas 에서 제공하는 to_datetime() 메서드를 사용해보자**

```
# 데이터 프레임에서 날짜 값으로 변경하고 싶은 열에 대해
# to_datetime 메서드의 인자값으로 넣으면 됨
day_table['날짜'] = pd.to_datetime(day_table['날짜'])

# 데이터 프레임 dtypes 조회
day_table.dtypes

# 출력 
날짜    datetime64[ns]
dtype: object

# 해당 날짜 시간 기본형이 아닌 문자열 또한 변환시킬수 있다!
birth = pd.to_datetime('1997년 9월 26일' , format = '%Y년 %m월 %d일')

# birth 출력
Timestamp('1997-09-26 00:00:00')
```

 5. 위의 소스 예시처럼 바뀌는 것을 볼수있다.

 6. 해당 메서드 외에 pandas에서는 dt 접근자로 날짜 데이터를 다양하게 변환 시킬 수 있다.

#### **파이썬 sr.dt 속성 및 메서드 정리**

|   |   |
|---|---|
|**구분**|**상세 내용**|
|**sr.dt.year**|sr의 원소에서 년(year)을 정수형 시리즈로 반환합니다.|
|**sr.dt.month**|sr의 원소에서 월(month)을 정수형 시리즈로 반환합니다.|
|**sr.dt.day**|sr의 원소에서 일(day)을 정수형 시리즈로 반환합니다.|
|**sr.dt.hour**|sr의 원소에서 시(hour)을 정수형 시리즈로 반환합니다.|
|**sr.dt.minute**|sr의 원소에서 분(minute)을 정수형 시리즈로 반환합니다.|
|**sr.dt.second**|sr의 원소에서 초(second)를 정수형 시리즈로 반환합니다.|
|**sr.dt.dayofweek**|sr의 원소에서 **요일을 정수형** 시리즈로 반환합니다. (Monday: 0, Sunday: 6)|
|**sr.dt.day_name()**|sr의 원소에서 **요일을 문자열** 시리즈로 반환합니다. (로케일에 따라 다름)|
|**sr.dt.strftime(date_format)**|sr의 원소에서 **지정한 날짜시간 포맷**의 문자열 시리즈로 반환합니다.|

## **문자열을 수치형으로 강제로 변환시키기**

 - 리스트 또는 데이터 프레임내에 넣을 데이터 중  'NULL'이라는 데이터가 종종 있는걸 종종 접하게 되는데

   **정수 또는 실수 데이터들 중 'NULL'값이 있는 상태로 넣게 된다면 해당 데이터 타입은 object로 될것**이다

 - 리스트 생성 후 **astype으로 변환**하면 되겠지라고 생각해서 명령을 호출 한다면 **'error'가 발생**하게 되는데

   **'NULL'은 문자열 타입으로 숫자형으로 변환한다고 하면 에러가 발생**하기 때문이다

그럼 해당 데이터는 어떻게 변환시켜야하나 ??

**숫자가 아닌 문자열을 포함하는 시리즈를 수치형으로 강제 변환시켜야한다!**

```
# 'NULL'이 포함된 넘버 시리즈 생성
numbers = pd.Series([1,2,3,4,'NULL'])

# 데이터 형식을 숫자형으로 변환
pd.to_numeric(arg = numbers)

# 에러발생
ValueError: Unable to parse string "NULL" at position 4
```

 - **4번째 포지션에 'NULL' 이라는 문자열은 사용할수없다고 에러**가 뜬다

 - 해당 에러를 무시하고 강제로 숫자형 시리즈로 변환시키기 위해서는 어떻게 해야할까 ?

    ->   **errors = 'coerce'라는 옵션을 세팅해주면 수치형으로 변환할 수 없는 문자열을 결측값으로 채워준다 라는 설정**이다.

```
# 'NULL'이 포함된 넘버 시리즈 생성
numbers = pd.Series([1,2,3,4,'NULL'])

# 데이터 형식을 숫자형으로 변환 , errors 인자값에 coerce 세팅
pd.to_numeric(arg = numbers ,errors = 'coerce')

# 출력
0    1.0
1    2.0
2    3.0
3    4.0
4    NaN
dtype: float64
```

## **카테고리**

 **- 시리즈의 astype 메서드에 category 타입으로 생성 가능**하다

 - 카테고리에 들어가는 **데이터들은 범주형 데이터**들이다

 - **범주형 데이터는 순서가 없는 데이터 들인 명목형 데이터 , 순서가 있는 데이터들인 서열형 데이터로 나뉜다**

### **명목형 데이터**

 **- 수치적인 의미가 없으며 대상을 구분하거나 분류하기 위해 사용되는 데이터** 

 - 순서나 크기비교가 불가능

 **- 원 - 핫 인코딩을 추천**한다

#### **원핫 인코딩??**

 - 항목의 열만 1로 만들고 나머지는 0으로 채우는 방식

 - 각 범주마다 별도의 열(컬럼)이 생성됨

 - 해당 범주에 속하면 1, 아니면 0으로 표시

 - 명목형 데이터에 적합 (순서가 없는 데이터)

 - 레이블 인코딩과 달리 숫자의 크기가 의미를 갖지 않음

 **예시 )**

 - 원본데이터를 준비한다 

|   |   |
|---|---|
|원본 데이터|색상|
|빨강|
|파랑|
|초록|
|빨강|

 - 원 핫 인코딩으로 다음과 같이 처리한다

|   |   |   |   |
|---|---|---|---|
|원 핫 인코딩 후|파랑|초록|빨강|
|1|0|0|
|0|1|0|
|0|0|1|
|1|0|0|

### **서열형 데이터**

 **- 항목 간 계층적인 순서나 순위가 존재하는 데이터** 

 - 우열이나 순서 비교가 가능

 - 간격이 일정하지는 않음

 **- 레이블 인코딩을 추천하지만 , 사용자가 인덱스 순서를 지정하고 싶을 경우에는 오디널 인코딩을 사용**한다.

#### **레이블 인코딩?**

 **- 범주형 데이터를 단순히 정수로 변환 하는 방식**

 - 각 범주를 정수로 변환

**예시)**

 - 원본 데이터를 준비한다

|   |   |
|---|---|
|원본 데이터|크기|
|작음|
|중간|
|큼|
|작음|

 - 레이블 인코딩을 다음과 같이 처리한다.

|   |   |   |
|---|---|---|
|레이블 인코딩 후|크기 인코딩|값|
|작음|0|
|중간|1|
|큼|2|
|작음|0|

#### **오디널 인코딩?**

 - 순서가 있는 범주형 데이터를 해당 순서에 맞게 정수로 변환하는 방식

 - 순서가 있는 범주형 데이터(서열형)에 적합

 - 범주 간의 순서 관계를 숫자로 표현

 - 사용자가 직접 순서를 지정할 수 있음

 - 머신러닝 모델이 범주 간의 순서 관계를 학습할 수 있음

**예시)**

|   |   |   |
|---|---|---|
|**원본 데이터**|**오디널 인코딩 후**|   |
|만족도|만족도|인코딩 값|
|매우 불만|매우 불만|0|
|불만|불만|1|
|보통|보통|2|
|만족|만족|3|
|매우 만족|매우 만족|4|
|보통|보통|2|

## **apply 메서드 ? ( ★★★★★** )

 - 사용시점 : **반복실행할때 apply 함수를 사용**

    ->for 루프 쓰면되는거 아냐 ? 데이터 분석에서는 for루프보다는 apply를 주로 사용함

 - 동작 : 데이터프레임의 행 또는 열 시리즈별로 지정한 함수를 반복 실행함

 - 행 또는 열에 내가 원하는 함수를 실행

 - 형태 예시 : (df = apply( func = 실행시키려는 함수 , axis = 방향(0 : 세로 , 1 : 가로) )

 **- 가능한 함수**

- **괄호 제거된 함수**

```
apt['아파트명'].apply(func = len)
```

- **def로 만든 함수**

```
def classify_crime(count):
    if count > 100: return "심각"
    else: return "보통"

df['위험도'] = df['건수'].apply(classify_crime)
```

- **lambda 함수**

```
# '범죄건수' 컬럼의 모든 값에 10을 더함
df['건수_plus_10'] = df['건수'].apply(lambda x: x + 10)
```

- **인자값이 여러개일 경우**
    - **def sum(a,b) 라고 하면 a값은 앞에 시리즈의 값이 들어가고 , b는 내가 세팅을 해줘야함**
    - **인수값을 세팅하면 그대로 넣어야함 b = 를 넣어야하는데 x = 넣는다 ? 에러발생**

```
def multiply(x, n):
    return x * n

# n=5라는 추가 인자값을 전달
df['건수_5배'] = df['건수'].apply(multiply, n = 5)
```

#### **map 메서드 ?**

 - map 함수도 원하는 함수를 세팅해서 반복할수있음

- 동작 : 셀값에 대한 func를 실행해줌
- map 함수도 동일하게 인자 값이 여러개일 경우 세팅해주면 된다

둘다 쓸수있는거 ?

- 시리즈는 map도 사용 할 수 있지만 주로 apply를 사용
- 데이터 프레임은 apply도 사용 할 수 있지만 주로 map을 사용